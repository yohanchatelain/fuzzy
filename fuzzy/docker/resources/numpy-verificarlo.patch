From e74cc9f8c8a5d92c4943cd1c6b9f003bb83ac970 Mon Sep 17 00:00:00 2001
From: yohanchatelain <yohan.chatelain@gmail.com>
Date: Thu, 17 Dec 2020 18:16:25 -0500
Subject: [PATCH] Add verificarlo compiler

---
 numpy/distutils/ccompiler.py              |  88 ++++++----
 numpy/distutils/fcompiler/__init__.py     | 201 +++++++++++++---------
 numpy/distutils/fcompiler/verificarlof.py |  78 +++++++++
 numpy/distutils/verificarloccompiler.py   |  24 +++
 4 files changed, 280 insertions(+), 111 deletions(-)
 create mode 100644 numpy/distutils/fcompiler/verificarlof.py
 create mode 100644 numpy/distutils/verificarloccompiler.py

diff --git a/numpy/distutils/ccompiler.py b/numpy/distutils/ccompiler.py
index 9ea083774..bf82ce706 100644
--- a/numpy/distutils/ccompiler.py
+++ b/numpy/distutils/ccompiler.py
@@ -22,8 +22,8 @@ from numpy.distutils.exec_command import (
     filepath_from_subprocess_output, forward_bytes_to_stdout
 )
 from numpy.distutils.misc_util import cyg2win32, is_sequence, mingw32, \
-                                      get_num_build_jobs, \
-                                      _commandline_dep_string
+    get_num_build_jobs, \
+    _commandline_dep_string
 
 # globals for parallel build management
 try:
@@ -61,7 +61,7 @@ def _needs_build(obj, cc_args, extra_postargs, pp_opts):
     with open(dep_file, "r") as f:
         lines = f.readlines()
 
-    cmdline =_commandline_dep_string(cc_args, extra_postargs, pp_opts)
+    cmdline = _commandline_dep_string(cc_args, extra_postargs, pp_opts)
     last_cmdline = lines[-1]
     if last_cmdline != cmdline:
         return True
@@ -92,9 +92,9 @@ def replace_method(klass, method_name, func):
 
 
 ######################################################################
-## Method that subclasses may redefine. But don't call this method,
-## it i private to CCompiler class and may return unexpected
-## results if used elsewhere. So, you have been warned..
+# Method that subclasses may redefine. But don't call this method,
+# it i private to CCompiler class and may return unexpected
+# results if used elsewhere. So, you have been warned..
 
 def CCompiler_find_executables(self):
     """
@@ -171,10 +171,12 @@ def CCompiler_spawn(self, cmd, display=None):
     else:
         msg = ''
     raise DistutilsExecError('Command "%s" failed with exit status %d%s' %
-                            (cmd, s, msg))
+                             (cmd, s, msg))
+
 
 replace_method(CCompiler, 'spawn', CCompiler_spawn)
 
+
 def CCompiler_object_filenames(self, source_filenames, strip_dir=0, output_dir=''):
     """
     Return the name of the object files for the given source files.
@@ -203,7 +205,7 @@ def CCompiler_object_filenames(self, source_filenames, strip_dir=0, output_dir='
     obj_names = []
     for src_name in source_filenames:
         base, ext = os.path.splitext(os.path.normpath(src_name))
-        base = os.path.splitdrive(base)[1] # Chop off the drive
+        base = os.path.splitdrive(base)[1]  # Chop off the drive
         base = base[os.path.isabs(base):]  # If abs, chop off leading /
         if base.startswith('..'):
             # Resolve starting relative path components, middle ones
@@ -213,15 +215,18 @@ def CCompiler_object_filenames(self, source_filenames, strip_dir=0, output_dir='
             d = os.path.basename(os.path.abspath(d))
             base = d + base[i:]
         if ext not in self.src_extensions:
-            raise UnknownFileError("unknown file type '%s' (from '%s')" % (ext, src_name))
+            raise UnknownFileError(
+                "unknown file type '%s' (from '%s')" % (ext, src_name))
         if strip_dir:
             base = os.path.basename(base)
         obj_name = os.path.join(output_dir, base + self.obj_extension)
         obj_names.append(obj_name)
     return obj_names
 
+
 replace_method(CCompiler, 'object_filenames', CCompiler_object_filenames)
 
+
 def CCompiler_compile(self, sources, output_dir=None, macros=None,
                       include_dirs=None, debug=0, extra_preargs=None,
                       extra_postargs=None, depends=None):
@@ -290,8 +295,8 @@ def CCompiler_compile(self, sources, output_dir=None, macros=None,
         display = "C compiler: %s\n" % (' '.join(ccomp),)
     log.info(display)
     macros, objects, extra_postargs, pp_opts, build = \
-            self._setup_compile(output_dir, macros, include_dirs, sources,
-                                depends, extra_postargs)
+        self._setup_compile(output_dir, macros, include_dirs, sources,
+                            depends, extra_postargs)
     cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)
     display = "compile options: '%s'" % (' '.join(cc_args))
     if extra_postargs:
@@ -324,14 +329,13 @@ def CCompiler_compile(self, sources, output_dir=None, macros=None,
             with _global_lock:
                 _processing_files.remove(obj)
 
-
     if isinstance(self, FCompiler):
         objects_to_build = list(build.keys())
         f77_objects, other_objects = [], []
         for obj in objects:
             if obj in objects_to_build:
                 src, ext = build[obj]
-                if self.compiler_type=='absoft':
+                if self.compiler_type == 'absoft':
                     obj = cyg2win32(obj)
                     src = cyg2win32(src)
                 if is_f_file(src) and not has_f90_header(src):
@@ -363,8 +367,10 @@ def CCompiler_compile(self, sources, output_dir=None, macros=None,
     # Return *all* object filenames, not just the ones we just built.
     return objects
 
+
 replace_method(CCompiler, 'compile', CCompiler_compile)
 
+
 def CCompiler_customize_cmd(self, cmd, ignore=()):
     """
     Customize compiler using distutils command.
@@ -386,6 +392,7 @@ def CCompiler_customize_cmd(self, cmd, ignore=()):
     """
     log.info('customize %s using %s' % (self.__class__.__name__,
                                         cmd.__class__.__name__))
+
     def allow(attr):
         return getattr(cmd, attr, None) is not None and attr not in ignore
 
@@ -406,8 +413,10 @@ def CCompiler_customize_cmd(self, cmd, ignore=()):
     if allow('link_objects'):
         self.set_link_objects(cmd.link_objects)
 
+
 replace_method(CCompiler, 'customize_cmd', CCompiler_customize_cmd)
 
+
 def _compiler_to_string(compiler):
     props = []
     mx = 0
@@ -426,6 +435,7 @@ def _compiler_to_string(compiler):
     lines = [fmt % prop for prop in props]
     return '\n'.join(lines)
 
+
 def CCompiler_show_customization(self):
     """
     Print the compiler customizations to stdout.
@@ -455,14 +465,16 @@ def CCompiler_show_customization(self):
         self.get_version()
     except Exception:
         pass
-    if log._global_log.threshold<2:
+    if log._global_log.threshold < 2:
         print('*'*80)
         print(self.__class__)
         print(_compiler_to_string(self))
         print('*'*80)
 
+
 replace_method(CCompiler, 'show_customization', CCompiler_show_customization)
 
+
 def CCompiler_customize(self, dist, need_cxx=0):
     """
     Do any platform-specific customization of a compiler instance.
@@ -512,13 +524,13 @@ def CCompiler_customize(self, dist, need_cxx=0):
                 else:
                     a, b = 'cc', 'c++'
                 self.compiler_cxx = [self.compiler[0].replace(a, b)]\
-                                    + self.compiler[1:]
+                    + self.compiler[1:]
         else:
             if hasattr(self, 'compiler'):
                 log.warn("#### %s #######" % (self.compiler,))
             if not hasattr(self, 'compiler_cxx'):
-                log.warn('Missing compiler_cxx fix for ' + self.__class__.__name__)
-
+                log.warn('Missing compiler_cxx fix for ' +
+                         self.__class__.__name__)
 
     # check if compiler supports gcc style automatic dependencies
     # run on every extension so skip for known good compilers
@@ -544,8 +556,10 @@ def CCompiler_customize(self, dist, need_cxx=0):
 
     return
 
+
 replace_method(CCompiler, 'customize', CCompiler_customize)
 
+
 def simple_version_match(pat=r'[-.\d]+', ignore='', start=''):
     """
     Simple matching of version numbers, for use in CCompiler and FCompiler.
@@ -572,6 +586,7 @@ def simple_version_match(pat=r'[-.\d]+', ignore='', start=''):
         a version string.
 
     """
+
     def matcher(self, version_string):
         # version string may appear in the second line, so getting rid
         # of new lines:
@@ -593,6 +608,7 @@ def simple_version_match(pat=r'[-.\d]+', ignore='', start=''):
         return m.group(0)
     return matcher
 
+
 def CCompiler_get_version(self, force=False, ok_status=[0]):
     """
     Return compiler version, or None if compiler is not available.
@@ -629,6 +645,7 @@ def CCompiler_get_version(self, force=False, ok_status=[0]):
             pat = self.version_pattern
         except AttributeError:
             return None
+
         def matcher(version_string):
             m = re.match(pat, version_string)
             if not m:
@@ -660,8 +677,10 @@ def CCompiler_get_version(self, force=False, ok_status=[0]):
     self.version = version
     return version
 
+
 replace_method(CCompiler, 'get_version', CCompiler_get_version)
 
+
 def CCompiler_cxx_compiler(self):
     """
     Return the C++ compiler.
@@ -684,11 +703,12 @@ def CCompiler_cxx_compiler(self):
     if sys.platform.startswith('aix') and 'ld_so_aix' in cxx.linker_so[0]:
         # AIX needs the ld_so_aix script included with Python
         cxx.linker_so = [cxx.linker_so[0], cxx.compiler_cxx[0]] \
-                        + cxx.linker_so[2:]
+            + cxx.linker_so[2:]
     else:
         cxx.linker_so = [cxx.compiler_cxx[0]] + cxx.linker_so[1:]
     return cxx
 
+
 replace_method(CCompiler, 'cxx_compiler', CCompiler_cxx_compiler)
 
 compiler_class['intel'] = ('intelccompiler', 'IntelCCompiler',
@@ -703,6 +723,8 @@ compiler_class['intelemw'] = ('intelccompiler', 'IntelEM64TCCompilerW',
                               "Intel C Compiler for 64-bit applications on Windows")
 compiler_class['pathcc'] = ('pathccompiler', 'PathScaleCCompiler',
                             "PathScale Compiler for SiCortex-based applications")
+compiler_class["verificarlo"] = ("verificarloccompiler", "VerificarloCCompiler",
+                                 "Verificarlo C Compiler")
 ccompiler._default_compilers += (('linux.*', 'intel'),
                                  ('linux.*', 'intele'),
                                  ('linux.*', 'intelem'),
@@ -712,22 +734,24 @@ ccompiler._default_compilers += (('linux.*', 'intel'),
 
 if sys.platform == 'win32':
     compiler_class['mingw32'] = ('mingw32ccompiler', 'Mingw32CCompiler',
-                                 "Mingw32 port of GNU C Compiler for Win32"\
+                                 "Mingw32 port of GNU C Compiler for Win32"
                                  "(for MSC built Python)")
     if mingw32():
         # On windows platforms, we want to default to mingw32 (gcc)
         # because msvc can't build blitz stuff.
         log.info('Setting mingw32 as default compiler for nt.')
         ccompiler._default_compilers = (('nt', 'mingw32'),) \
-                                       + ccompiler._default_compilers
+            + ccompiler._default_compilers
 
 
 _distutils_new_compiler = new_compiler
-def new_compiler (plat=None,
-                  compiler=None,
-                  verbose=None,
-                  dry_run=0,
-                  force=0):
+
+
+def new_compiler(plat=None,
+                 compiler=None,
+                 verbose=None,
+                 dry_run=0,
+                 force=0):
     # Try first C compilers from numpy.distutils.
     if verbose is None:
         verbose = log.get_threshold() <= log.INFO
@@ -744,7 +768,7 @@ def new_compiler (plat=None,
         raise DistutilsPlatformError(msg)
     module_name = "numpy.distutils." + module_name
     try:
-        __import__ (module_name)
+        __import__(module_name)
     except ImportError as e:
         msg = str(e)
         log.info('%s in numpy.distutils; trying from distutils',
@@ -754,22 +778,25 @@ def new_compiler (plat=None,
             __import__(module_name)
         except ImportError as e:
             msg = str(e)
-            raise DistutilsModuleError("can't compile C/C++ code: unable to load module '%s'" % \
-                  module_name)
+            raise DistutilsModuleError("can't compile C/C++ code: unable to load module '%s'" %
+                                       module_name)
     try:
         module = sys.modules[module_name]
         klass = vars(module)[class_name]
     except KeyError:
         raise DistutilsModuleError(("can't compile C/C++ code: unable to find class '%s' " +
-               "in module '%s'") % (class_name, module_name))
+                                    "in module '%s'") % (class_name, module_name))
     compiler = klass(None, dry_run, force)
     compiler.verbose = verbose
     log.debug('new_compiler returns %s' % (klass))
     return compiler
 
+
 ccompiler.new_compiler = new_compiler
 
 _distutils_gen_lib_options = gen_lib_options
+
+
 def gen_lib_options(compiler, library_dirs, runtime_library_dirs, libraries):
     # the version of this function provided by CPython allows the following
     # to return lists, which are unpacked automatically:
@@ -787,6 +814,8 @@ def gen_lib_options(compiler, library_dirs, runtime_library_dirs, libraries):
         else:
             lib_opts.append(i)
     return lib_opts
+
+
 ccompiler.gen_lib_options = gen_lib_options
 
 # Also fix up the various compiler modules, which do
@@ -796,4 +825,3 @@ for _cc in ['msvc9', 'msvc', '_msvc', 'bcpp', 'cygwinc', 'emxc', 'unixc']:
     _m = sys.modules.get('distutils.' + _cc + 'compiler')
     if _m is not None:
         setattr(_m, 'gen_lib_options', gen_lib_options)
-
diff --git a/numpy/distutils/fcompiler/__init__.py b/numpy/distutils/fcompiler/__init__.py
index 1c3069363..6a050cdc7 100644
--- a/numpy/distutils/fcompiler/__init__.py
+++ b/numpy/distutils/fcompiler/__init__.py
@@ -25,7 +25,7 @@ from numpy.compat import open_latin1
 from distutils.sysconfig import get_python_lib
 from distutils.fancy_getopt import FancyGetopt
 from distutils.errors import DistutilsModuleError, \
-     DistutilsExecError, CompileError, LinkError, DistutilsPlatformError
+    DistutilsExecError, CompileError, LinkError, DistutilsPlatformError
 from distutils.util import split_quoted, strtobool
 
 from numpy.distutils.ccompiler import CCompiler, gen_lib_options
@@ -39,23 +39,28 @@ from .environment import EnvironmentConfig
 
 __metaclass__ = type
 
+
 class CompilerNotFound(Exception):
     pass
 
+
 def flaglist(s):
     if is_string(s):
         return split_quoted(s)
     else:
         return s
 
+
 def str2bool(s):
     if is_string(s):
         return strtobool(s)
     return bool(s)
 
+
 def is_sequence_of_strings(seq):
     return is_sequence(seq) and all_strings(seq)
 
+
 class FCompiler(CCompiler):
     """Abstract base class to define the interface that must be implemented
     by real Fortran compiler classes.
@@ -99,43 +104,43 @@ class FCompiler(CCompiler):
 
     distutils_vars = EnvironmentConfig(
         distutils_section='config_fc',
-        noopt = (None, None, 'noopt', str2bool, False),
-        noarch = (None, None, 'noarch', str2bool, False),
-        debug = (None, None, 'debug', str2bool, False),
-        verbose = (None, None, 'verbose', str2bool, False),
+        noopt=(None, None, 'noopt', str2bool, False),
+        noarch=(None, None, 'noarch', str2bool, False),
+        debug=(None, None, 'debug', str2bool, False),
+        verbose=(None, None, 'verbose', str2bool, False),
     )
 
     command_vars = EnvironmentConfig(
         distutils_section='config_fc',
-        compiler_f77 = ('exe.compiler_f77', 'F77', 'f77exec', None, False),
-        compiler_f90 = ('exe.compiler_f90', 'F90', 'f90exec', None, False),
-        compiler_fix = ('exe.compiler_fix', 'F90', 'f90exec', None, False),
-        version_cmd = ('exe.version_cmd', None, None, None, False),
-        linker_so = ('exe.linker_so', 'LDSHARED', 'ldshared', None, False),
-        linker_exe = ('exe.linker_exe', 'LD', 'ld', None, False),
-        archiver = (None, 'AR', 'ar', None, False),
-        ranlib = (None, 'RANLIB', 'ranlib', None, False),
+        compiler_f77=('exe.compiler_f77', 'F77', 'f77exec', None, False),
+        compiler_f90=('exe.compiler_f90', 'F90', 'f90exec', None, False),
+        compiler_fix=('exe.compiler_fix', 'F90', 'f90exec', None, False),
+        version_cmd=('exe.version_cmd', None, None, None, False),
+        linker_so=('exe.linker_so', 'LDSHARED', 'ldshared', None, False),
+        linker_exe=('exe.linker_exe', 'LD', 'ld', None, False),
+        archiver=(None, 'AR', 'ar', None, False),
+        ranlib=(None, 'RANLIB', 'ranlib', None, False),
     )
 
     flag_vars = EnvironmentConfig(
         distutils_section='config_fc',
-        f77 = ('flags.f77', 'F77FLAGS', 'f77flags', flaglist, True),
-        f90 = ('flags.f90', 'F90FLAGS', 'f90flags', flaglist, True),
-        free = ('flags.free', 'FREEFLAGS', 'freeflags', flaglist, True),
-        fix = ('flags.fix', None, None, flaglist, False),
-        opt = ('flags.opt', 'FOPT', 'opt', flaglist, True),
-        opt_f77 = ('flags.opt_f77', None, None, flaglist, False),
-        opt_f90 = ('flags.opt_f90', None, None, flaglist, False),
-        arch = ('flags.arch', 'FARCH', 'arch', flaglist, False),
-        arch_f77 = ('flags.arch_f77', None, None, flaglist, False),
-        arch_f90 = ('flags.arch_f90', None, None, flaglist, False),
-        debug = ('flags.debug', 'FDEBUG', 'fdebug', flaglist, True),
-        debug_f77 = ('flags.debug_f77', None, None, flaglist, False),
-        debug_f90 = ('flags.debug_f90', None, None, flaglist, False),
-        flags = ('self.get_flags', 'FFLAGS', 'fflags', flaglist, True),
-        linker_so = ('flags.linker_so', 'LDFLAGS', 'ldflags', flaglist, True),
-        linker_exe = ('flags.linker_exe', 'LDFLAGS', 'ldflags', flaglist, True),
-        ar = ('flags.ar', 'ARFLAGS', 'arflags', flaglist, True),
+        f77=('flags.f77', 'F77FLAGS', 'f77flags', flaglist, True),
+        f90=('flags.f90', 'F90FLAGS', 'f90flags', flaglist, True),
+        free=('flags.free', 'FREEFLAGS', 'freeflags', flaglist, True),
+        fix=('flags.fix', None, None, flaglist, False),
+        opt=('flags.opt', 'FOPT', 'opt', flaglist, True),
+        opt_f77=('flags.opt_f77', None, None, flaglist, False),
+        opt_f90=('flags.opt_f90', None, None, flaglist, False),
+        arch=('flags.arch', 'FARCH', 'arch', flaglist, False),
+        arch_f77=('flags.arch_f77', None, None, flaglist, False),
+        arch_f90=('flags.arch_f90', None, None, flaglist, False),
+        debug=('flags.debug', 'FDEBUG', 'fdebug', flaglist, True),
+        debug_f77=('flags.debug_f77', None, None, flaglist, False),
+        debug_f90=('flags.debug_f90', None, None, flaglist, False),
+        flags=('self.get_flags', 'FFLAGS', 'fflags', flaglist, True),
+        linker_so=('flags.linker_so', 'LDFLAGS', 'ldflags', flaglist, True),
+        linker_exe=('flags.linker_exe', 'LDFLAGS', 'ldflags', flaglist, True),
+        ar=('flags.ar', 'ARFLAGS', 'arflags', flaglist, True),
     )
 
     language_map = {'.f': 'f77',
@@ -149,7 +154,6 @@ class FCompiler(CCompiler):
                     }
     language_order = ['f90', 'f77']
 
-
     # These will be set by the subclass
 
     compiler_type = None
@@ -166,7 +170,7 @@ class FCompiler(CCompiler):
         'linker_exe': ["f90"],
         'archiver': ["ar", "-cr"],
         'ranlib': None,
-        }
+    }
 
     # If compiler does not support compiling Fortran 90 then it can
     # suggest using another compiler. For example, gnu would suggest
@@ -175,9 +179,9 @@ class FCompiler(CCompiler):
 
     compile_switch = "-c"
     object_switch = "-o "   # Ending space matters! It will be stripped
-                            # but if it is missing then object_switch
-                            # will be prefixed to object file name by
-                            # string concatenation.
+    # but if it is missing then object_switch
+    # will be prefixed to object file name by
+    # string concatenation.
     library_switch = "-o "  # Ditto!
 
     # Switch to specify where module files are created and searched
@@ -190,12 +194,13 @@ class FCompiler(CCompiler):
 
     pic_flags = []           # Flags to create position-independent code
 
-    src_extensions = ['.for', '.ftn', '.f77', '.f', '.f90', '.f95', '.F', '.F90', '.FOR']
+    src_extensions = ['.for', '.ftn', '.f77',
+                      '.f', '.f90', '.f95', '.F', '.F90', '.FOR']
     obj_extension = ".o"
 
     shared_lib_extension = get_shared_lib_extension()
     static_lib_extension = ".a"  # or .lib
-    static_lib_format = "lib%s%s" # or %s%s
+    static_lib_format = "lib%s%s"  # or %s%s
     shared_lib_format = "%s%s"
     exe_extension = ""
 
@@ -275,9 +280,9 @@ class FCompiler(CCompiler):
         self.executables[key] = value
 
     ######################################################################
-    ## Methods that subclasses may redefine. But don't call these methods!
-    ## They are private to FCompiler class and may return unexpected
-    ## results if used elsewhere. So, you have been warned..
+    # Methods that subclasses may redefine. But don't call these methods!
+    # They are private to FCompiler class and may return unexpected
+    # results if used elsewhere. So, you have been warned..
 
     def find_executables(self):
         """Go through the self.executables dictionary, and attempt to
@@ -295,17 +300,20 @@ class FCompiler(CCompiler):
         """
         assert self._is_customised
         exe_cache = self._exe_cache
+
         def cached_find_executable(exe):
             if exe in exe_cache:
                 return exe_cache[exe]
             fc_exe = find_executable(exe)
             exe_cache[exe] = exe_cache[fc_exe] = fc_exe
             return fc_exe
+
         def verify_command_form(name, value):
             if value is not None and not is_sequence_of_strings(value):
                 raise ValueError(
                     "%s value %r is invalid in class %s" %
                     (name, value, self.__class__.__name__))
+
         def set_exe(exe_key, f77=None, f90=None):
             cmd = self.executables.get(exe_key, None)
             if not cmd:
@@ -382,30 +390,39 @@ class FCompiler(CCompiler):
     def get_flags_f77(self):
         """List of Fortran 77 specific flags."""
         return self._get_command_flags('compiler_f77')
+
     def get_flags_f90(self):
         """List of Fortran 90 specific flags."""
         return self._get_command_flags('compiler_f90')
+
     def get_flags_free(self):
         """List of Fortran 90 free format specific flags."""
         return []
+
     def get_flags_fix(self):
         """List of Fortran 90 fixed format specific flags."""
         return self._get_command_flags('compiler_fix')
+
     def get_flags_linker_so(self):
         """List of linker flags to build a shared library."""
         return self._get_command_flags('linker_so')
+
     def get_flags_linker_exe(self):
         """List of linker flags to build an executable."""
         return self._get_command_flags('linker_exe')
+
     def get_flags_ar(self):
         """List of archiver flags. """
         return self._get_command_flags('archiver')
+
     def get_flags_opt(self):
         """List of architecture independent compiler flags."""
         return []
+
     def get_flags_arch(self):
         """List of architecture dependent compiler flags."""
         return []
+
     def get_flags_debug(self):
         """List of compiler flags to compile with debugging information."""
         return []
@@ -417,6 +434,7 @@ class FCompiler(CCompiler):
     def get_libraries(self):
         """List of compiler libraries."""
         return self.libraries[:]
+
     def get_library_dirs(self):
         """List of compiler library directories."""
         return self.library_dirs[:]
@@ -428,12 +446,11 @@ class FCompiler(CCompiler):
             raise CompilerNotFound()
         return version
 
-
     ############################################################
 
-    ## Public methods:
+    # Public methods:
 
-    def customize(self, dist = None):
+    def customize(self, dist=None):
         """Customize Fortran compiler.
 
         This method gets Fortran compiler specific information from
@@ -493,6 +510,7 @@ class FCompiler(CCompiler):
         oflags, aflags, dflags = [], [], []
         # examine get_flags_<tag>_<compiler> for extra flags
         # only add them if the method is different from get_flags_<tag>
+
         def get_flags(tag, flags):
             # note that self.flag_vars.<tag> calls self.get_flags_<tag>()
             flags.extend(getattr(self.flag_vars, tag))
@@ -519,8 +537,7 @@ class FCompiler(CCompiler):
         if fix:
             self.set_commands(compiler_fix=fix+fixflags+fflags)
 
-
-        #XXX: Do we need LDSHARED->SOSHARED, LDFLAGS->SOFLAGS
+        # XXX: Do we need LDSHARED->SOSHARED, LDFLAGS->SOFLAGS
         linker_so = self.linker_so
         if linker_so:
             linker_so_flags = self.flag_vars.linker_so
@@ -556,9 +573,9 @@ class FCompiler(CCompiler):
         props.sort()
 
         pretty_printer = FancyGetopt(props)
-        for l in pretty_printer.generate_help("%s instance properties:" \
+        for l in pretty_printer.generate_help("%s instance properties:"
                                               % (self.__class__.__name__)):
-            if l[:4]=='  --':
+            if l[:4] == '  --':
                 l = '  ' + l[4:]
             print(l)
 
@@ -576,17 +593,17 @@ class FCompiler(CCompiler):
             flavor = ':f90'
             compiler = self.compiler_f90
             if compiler is None:
-                raise DistutilsExecError('f90 not supported by %s needed for %s'\
-                      % (self.__class__.__name__, src))
+                raise DistutilsExecError('f90 not supported by %s needed for %s'
+                                         % (self.__class__.__name__, src))
             extra_compile_args = self.extra_f90_compile_args or []
         else:
             flavor = ':fix'
             compiler = self.compiler_fix
             if compiler is None:
-                raise DistutilsExecError('f90 (fixed) not supported by %s needed for %s'\
-                      % (self.__class__.__name__, src))
+                raise DistutilsExecError('f90 (fixed) not supported by %s needed for %s'
+                                         % (self.__class__.__name__, src))
             extra_compile_args = self.extra_f90_compile_args or []
-        if self.object_switch[-1]==' ':
+        if self.object_switch[-1] == ' ':
             o_args = [self.object_switch.strip(), obj]
         else:
             o_args = [self.object_switch.strip()+obj]
@@ -595,16 +612,16 @@ class FCompiler(CCompiler):
         s_args = [self.compile_switch, src]
 
         if extra_compile_args:
-            log.info('extra %s options: %r' \
+            log.info('extra %s options: %r'
                      % (flavor[1:], ' '.join(extra_compile_args)))
 
         extra_flags = src_flags.get(self.compiler_type, [])
         if extra_flags:
-            log.info('using compile options from source: %r' \
+            log.info('using compile options from source: %r'
                      % ' '.join(extra_flags))
 
         command = compiler + cc_args + extra_flags + s_args + o_args \
-                  + extra_postargs + extra_compile_args
+            + extra_postargs + extra_compile_args
 
         display = '%s: %s' % (os.path.basename(compiler[0]) + flavor,
                               src)
@@ -617,12 +634,14 @@ class FCompiler(CCompiler):
     def module_options(self, module_dirs, module_build_dir):
         options = []
         if self.module_dir_switch is not None:
-            if self.module_dir_switch[-1]==' ':
-                options.extend([self.module_dir_switch.strip(), module_build_dir])
+            if self.module_dir_switch[-1] == ' ':
+                options.extend(
+                    [self.module_dir_switch.strip(), module_build_dir])
             else:
                 options.append(self.module_dir_switch.strip()+module_build_dir)
         else:
-            print('XXX: module_build_dir=%r option ignored' % (module_build_dir))
+            print('XXX: module_build_dir=%r option ignored' %
+                  (module_build_dir))
             print('XXX: Fix module_dir_switch for ', self.__class__.__name__)
         if self.module_include_switch is not None:
             for d in [module_build_dir]+module_dirs:
@@ -634,6 +653,7 @@ class FCompiler(CCompiler):
 
     def library_option(self, lib):
         return "-l" + lib
+
     def library_dir_option(self, dir):
         return "-L" + dir
 
@@ -654,7 +674,7 @@ class FCompiler(CCompiler):
             raise TypeError("'output_dir' must be a string or None")
 
         if self._need_link(objects, output_filename):
-            if self.library_switch[-1]==' ':
+            if self.library_switch[-1] == ' ':
                 o_args = [self.library_switch.strip(), output_filename]
             else:
                 o_args = [self.library_switch.strip()+output_filename]
@@ -738,7 +758,8 @@ class FCompiler(CCompiler):
         """
         raise NotImplementedError()
 
-    ## class FCompiler
+    # class FCompiler
+
 
 _default_compilers = (
     # sys.platform mappings
@@ -746,20 +767,21 @@ _default_compilers = (
                'intelvem', 'intelem', 'flang')),
     ('cygwin.*', ('gnu', 'intelv', 'absoft', 'compaqv', 'intelev', 'gnu95', 'g95')),
     ('linux.*', ('gnu95', 'intel', 'lahey', 'pg', 'absoft', 'nag', 'vast', 'compaq',
-                 'intele', 'intelem', 'gnu', 'g95', 'pathf95', 'nagfor')),
+                 'intele', 'intelem', 'gnu', 'g95', 'pathf95', 'nagfor', 'verificarlof')),
     ('darwin.*', ('gnu95', 'nag', 'absoft', 'ibm', 'intel', 'gnu', 'g95', 'pg')),
     ('sunos.*', ('sun', 'gnu', 'gnu95', 'g95')),
     ('irix.*', ('mips', 'gnu', 'gnu95',)),
     ('aix.*', ('ibm', 'gnu', 'gnu95',)),
     # os.name mappings
-    ('posix', ('gnu', 'gnu95',)),
+    ('posix', ('gnu', 'gnu95', "verificarlof",)),
     ('nt', ('gnu', 'gnu95',)),
     ('mac', ('gnu95', 'gnu', 'pg')),
-    )
+)
 
 fcompiler_class = None
 fcompiler_aliases = None
 
+
 def load_all_fcompiler_classes():
     """Cache all the FCompiler classes found in modules in the
     numpy.distutils.fcompiler package.
@@ -774,7 +796,7 @@ def load_all_fcompiler_classes():
     for fname in glob(pys):
         module_name, ext = os.path.splitext(os.path.basename(fname))
         module_name = 'numpy.distutils.fcompiler.' + module_name
-        __import__ (module_name)
+        __import__(module_name)
         module = sys.modules[module_name]
         if hasattr(module, 'compilers'):
             for cname in module.compilers:
@@ -788,6 +810,7 @@ def load_all_fcompiler_classes():
                                             fcompiler_aliases[alias][1].__name__))
                     fcompiler_aliases[alias] = desc
 
+
 def _find_existing_fcompiler(compiler_types,
                              osname=None, platform=None,
                              requiref90=False,
@@ -818,13 +841,16 @@ def _find_existing_fcompiler(compiler_types,
                 raise ValueError('%s does not support compiling f90 codes, '
                                  'skipping.' % (c.__class__.__name__))
         except DistutilsModuleError:
-            log.debug("_find_existing_fcompiler: compiler_type='%s' raised DistutilsModuleError", compiler_type)
+            log.debug(
+                "_find_existing_fcompiler: compiler_type='%s' raised DistutilsModuleError", compiler_type)
         except CompilerNotFound:
-            log.debug("_find_existing_fcompiler: compiler_type='%s' not found", compiler_type)
+            log.debug(
+                "_find_existing_fcompiler: compiler_type='%s' not found", compiler_type)
         if v is not None:
             return compiler_type
     return None
 
+
 def available_fcompilers_for_platform(osname=None, platform=None):
     if osname is None:
         osname = os.name
@@ -840,6 +866,7 @@ def available_fcompilers_for_platform(osname=None, platform=None):
         matching_compiler_types.append('gnu')
     return matching_compiler_types
 
+
 def get_default_fcompiler(osname=None, platform=None, requiref90=False,
                           c_compiler=None):
     """Determine the default Fortran compiler to use for the given
@@ -848,23 +875,25 @@ def get_default_fcompiler(osname=None, platform=None, requiref90=False,
                                                                 platform)
     log.info("get_default_fcompiler: matching types: '%s'",
              matching_compiler_types)
-    compiler_type =  _find_existing_fcompiler(matching_compiler_types,
-                                              osname=osname,
-                                              platform=platform,
-                                              requiref90=requiref90,
-                                              c_compiler=c_compiler)
+    compiler_type = _find_existing_fcompiler(matching_compiler_types,
+                                             osname=osname,
+                                             platform=platform,
+                                             requiref90=requiref90,
+                                             c_compiler=c_compiler)
     return compiler_type
 
+
 # Flag to avoid rechecking for Fortran compiler every time
 failed_fcompilers = set()
 
+
 def new_fcompiler(plat=None,
                   compiler=None,
                   verbose=0,
                   dry_run=0,
                   force=0,
                   requiref90=False,
-                  c_compiler = None):
+                  c_compiler=None):
     """Generate an instance of some FCompiler subclass for the supplied
     platform/compiler combination.
     """
@@ -888,7 +917,7 @@ def new_fcompiler(plat=None,
         if compiler is not None:
             msg = msg + " with '%s' compiler." % compiler
             msg = msg + " Supported compilers are: %s)" \
-                  % (','.join(fcompiler_class.keys()))
+                % (','.join(fcompiler_class.keys()))
         log.warn(msg)
         failed_fcompilers.add(fcompiler_key)
         return None
@@ -897,6 +926,7 @@ def new_fcompiler(plat=None,
     compiler.c_compiler = c_compiler
     return compiler
 
+
 def show_fcompilers(dist=None):
     """Print list of available compilers (used by the "--help-fcompiler"
     option to "config_fc").
@@ -933,7 +963,7 @@ def show_fcompilers(dist=None):
 
         if v is None:
             compilers_na.append(("fcompiler="+compiler, None,
-                              fcompiler_class[compiler][2]))
+                                 fcompiler_class[compiler][2]))
         else:
             c.dump_properties()
             compilers.append(("fcompiler="+compiler, None,
@@ -970,6 +1000,7 @@ _has_f90_header = re.compile(r'-[*]-\s*f90\s*-[*]-', re.I).search
 _has_fix_header = re.compile(r'-[*]-\s*fix\s*-[*]-', re.I).search
 _free_f90_start = re.compile(r'[^c*!]\s*[^\s\d\t]', re.I).match
 
+
 def is_free_format(file):
     """Check if file is in free format Fortran."""
     # f90 allows both fixed and free format, assuming fixed unless
@@ -977,30 +1008,35 @@ def is_free_format(file):
     result = 0
     f = open_latin1(file, 'r')
     line = f.readline()
-    n = 10000 # the number of non-comment lines to scan for hints
+    n = 10000  # the number of non-comment lines to scan for hints
     if _has_f_header(line):
         n = 0
     elif _has_f90_header(line):
         n = 0
         result = 1
-    while n>0 and line:
+    while n > 0 and line:
         line = line.rstrip()
-        if line and line[0]!='!':
+        if line and line[0] != '!':
             n -= 1
-            if (line[0]!='\t' and _free_f90_start(line[:5])) or line[-1:]=='&':
+            if (line[0] != '\t' and _free_f90_start(line[:5])) or line[-1:] == '&':
                 result = 1
                 break
         line = f.readline()
     f.close()
     return result
 
+
 def has_f90_header(src):
     f = open_latin1(src, 'r')
     line = f.readline()
     f.close()
     return _has_f90_header(line) or _has_fix_header(line)
 
-_f77flags_re = re.compile(r'(c|)f77flags\s*\(\s*(?P<fcname>\w+)\s*\)\s*=\s*(?P<fflags>.*)', re.I)
+
+_f77flags_re = re.compile(
+    r'(c|)f77flags\s*\(\s*(?P<fcname>\w+)\s*\)\s*=\s*(?P<fflags>.*)', re.I)
+
+
 def get_f77flags(src):
     """
     Search the first 20 lines of fortran 77 code for line pattern
@@ -1012,9 +1048,11 @@ def get_f77flags(src):
     i = 0
     for line in f:
         i += 1
-        if i>20: break
+        if i > 20:
+            break
         m = _f77flags_re.match(line)
-        if not m: continue
+        if not m:
+            continue
         fcname = m.group('fcname').strip()
         fflags = m.group('fflags').strip()
         flags[fcname] = split_quoted(fflags)
@@ -1023,5 +1061,6 @@ def get_f77flags(src):
 
 # TODO: implement get_f90flags and use it in _compile similarly to get_f77flags
 
+
 if __name__ == '__main__':
     show_fcompilers()
diff --git a/numpy/distutils/fcompiler/verificarlof.py b/numpy/distutils/fcompiler/verificarlof.py
new file mode 100644
index 000000000..6a3d49c05
--- /dev/null
+++ b/numpy/distutils/fcompiler/verificarlof.py
@@ -0,0 +1,78 @@
+from __future__ import division, absolute_import, print_function
+import functools
+
+import sys
+
+from numpy.distutils.fcompiler import FCompiler, dummy_fortran_file
+from sys import platform
+from os.path import join, dirname, normpath
+
+compilers = ['VerificarloFlangCompiler']
+
+
+class VerificarloFlangCompiler(FCompiler):
+    compiler_type = 'verificarlof'
+    description = 'Verificarlo Compiler'
+    version_pattern = r'\s*clang.*version (?P<version>[\d.-]+).*'
+
+    ar_exe = 'lib.exe'
+    possible_executables = ['verificarlo-f']
+
+    executables = {
+        'version_cmd': ["", "--version"],
+        'compiler_f77': ["verificarlo-f"],
+        'compiler_fix': ["verificarlo-f", "-ffixed-form"],
+        'compiler_f90': ["verificarlo-f"],
+        'linker_so': ["verificarlo-f", "-fPIC", "-shared"],
+        'archiver': ["ar", "-cr"],
+        'ranlib':  None
+    }
+
+    pic_flags = ["-fPIC", "-DPIC"]
+    c_compiler = 'verificarlo-c'
+    module_dir_switch = '-module '  # Don't remove ending space!
+
+    def get_version(self):
+        return "7.0.1"
+
+    def get_libraries(self):
+        opt = FCompiler.get_libraries(self)
+        opt.extend(['flang', 'flangrti', 'ompstub'])
+        return opt
+
+    @functools.lru_cache(maxsize=128)
+    def get_library_dirs(self):
+        """List of compiler library directories."""
+        opt = FCompiler.get_library_dirs(self)
+        flang_dir = dirname(self.executables['compiler_f77'][0])
+        opt.append(normpath(join(flang_dir, '..', 'lib')))
+
+        return opt
+
+    def get_flags(self):
+        return ["-fPIC"]
+
+    def get_flags_free(self):
+        return []
+
+    def get_flags_debug(self):
+        return ['']
+
+    def get_flags_opt(self):
+        return ['-O3']
+
+    def get_flags_arch(self):
+        return []
+
+    def get_flags_linker_so(self):
+        return ["-shared", '-fPIC']
+
+    def runtime_library_dir_option(self, dir):
+        return '-Wl,-rpath=%s' % dir
+
+
+if __name__ == '__main__':
+    from distutils import log
+    log.set_verbosity(2)
+    from numpy.distutils import customized_fcompiler
+    print(customized_fcompiler(compiler='verificarlo-f').get_version())
diff --git a/numpy/distutils/verificarloccompiler.py b/numpy/distutils/verificarloccompiler.py
new file mode 100644
index 000000000..03ad68a38
--- /dev/null
+++ b/numpy/distutils/verificarloccompiler.py
@@ -0,0 +1,24 @@
+from __future__ import division, absolute_import, print_function
+
+from distutils.unixccompiler import UnixCCompiler
+
+
+class VerificarloCCompiler(UnixCCompiler):
+
+    """
+    Verificarlo compiler.
+    """
+
+    compiler_type = 'verificarlo'
+    cc_exe = 'verificarlo-c'
+    cxx_exe = 'verificarlo-c++'
+
+    def __init__(self, verbose=0, dry_run=0, force=0):
+        UnixCCompiler.__init__(self, verbose, dry_run, force)
+        cc_compiler = self.cc_exe
+        cxx_compiler = self.cxx_exe
+        self.set_executables(compiler=cc_compiler + ' -fPIC -mcpu=native -O3',
+                             compiler_so=cc_compiler + ' -shared -fPIC -mcpu=native -O3',
+                             compiler_cxx=cxx_compiler + ' -fPIC -mcpu=native -O3',
+                             linker_exe=cc_compiler + ' -fPIC -shared',
+                             linker_so=cc_compiler + ' -fPIC -shared')
-- 
2.25.1

